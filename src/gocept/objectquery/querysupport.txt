==================
Using QuerySupport
==================

ObjectParser
============

Initialization
--------------

ObjectParser looks inside objects for attributes and following objects. First
we create such an object:

    >>> class Child1(object):
    ...     pass
    >>> class Child2(object):
    ...     pass
    >>> class Child3(object):
    ...     pass
    >>> class Child4(object):
    ...     misc = Child1()

    >>> class ToParse(object):
    ...     some_var = ["some tupel", (Child2(), Child3())]
    ...     other_var = {"foo": "bar"}
    ...     _private_var = 10
    ...     desc = Child4()
    ...
    ...     def some_method(self):
    ...         pass

    >>> obj = ToParse()

You get an ObjectParser like this:

    >>> from gocept.objectquery.querysupport import ObjectParser
    >>> op = ObjectParser()
    >>> op
    <gocept.objectquery.querysupport.ObjectParser object at 0x...>


To get all found attributes, use the get_attributes() method:

    >>> attributes = op.get_attributes(obj)
    >>> attributes
    <generator object at 0x...>
    >>> sorted(list(attributes))
    ['desc', 'other_var', 'some_var']

To get all descendants, use the appropriate method. Note, that Child1 is not
part of the results because its a descendant of Child4:

    >>> descendants = op.get_descendants(obj)
    >>> descendants
    <generator object at 0x...>
    >>> r = list(descendants)
    >>> sorted(r)
    [<Child2 object at 0x...>, <Child3 object at 0x...>, <Child4 object at 0x...>]
    >>> len(r)
    3


EEJoin
======

Initialization
--------------

Import and create a ZODB to store the indexes:

    >>> from ZODB import MappingStorage, DB
    >>> from persistent import Persistent
    >>> import transaction
    >>> storage = MappingStorage.MappingStorage()
    >>> db = DB(storage)
    >>> conn = db.open()
    >>> dbroot = conn.root()

EEJoin (Element-Element-Join) joins two lists with the help of the
StructureIndex. First we need a StructureIndex and the EEJoin:

    >>> from gocept.objectquery.indexsupport import StructureIndex
    >>> from gocept.objectquery.querysupport import EEJoin
    >>> si = StructureIndex(dbroot)
    >>> eejoin = EEJoin(si)

Fill the StructureIndex with data:

    >>> si.insert(1)
    >>> si.insert(2, 1)
    >>> si.insert(3, 1)
    >>> si.insert(2, 3)
    >>> si.insert(4, 2)
    >>> si.insert(5, 1)
    >>> si.insert(4, 5)

A simple query. Which out of 2, 3 and 4 is reachable by 5:

    >>> eejoin([(5, 5)], [(2, 2), (3, 3), (4, 4)])
    [(5, 4)]

Some related queries:

    >>> eejoin([(1, 1)], [(1, 1)])
    []
    >>> eejoin([(5, 5)], [(1, 1)])
    []
    >>> eejoin([(1, 1)], [(1, 1), (2, 2), (3, 4), (5, 5)])
    [(1, 2), (1, 4), (1, 5)]

EAJoin
======

The EAJoin joins two lists of objects. The first list holds all objects which
match the element condition in a PathExpression query. The second list holds
all objects which match the attribute and value condition (predicate)
evaluated by the ObjectCollection.

First instantiate some data:

    >>> class A(object):
    ...     value = 1
    >>> class B(object):
    ...     value = 4
    >>> class C(object):
    ...     offset = '9'
    ...     string = 'something'

    >>> a = A(); b = B(); c = C()

Here some example use-cases:

    >>> from gocept.objectquery.querysupport import EAJoin
    >>> ea = EAJoin()
    >>> r = ea([(a, a), (b, b), (c, c)], 'value', 1)
    >>> len(r) == 1 and r[0] == (a, a)
    True

    >>> r = ea([(a, a), (a, b), (a, c)], 'value', 5, "<")
    >>> len(r) == 2 and r[0] == (a, a) and r[1] == (a, b)
    True

    >>> r = ea([(a, a), (b, b), (a, c)], 'offset', '10', "!=")
    >>> len(r) == 1 and r[0] == (a, c)
    True

    >>> r = ea([(a, b), (a, c)], 'value')
    >>> len(r) == 1 and r[0] == (a, b)
    True

Duplicate results are well ignored:

    >>> r = ea([(a, a), (a, a)], 'value', 1)
    >>> len(r) == 1 and r[0] == (a, a)
    True

You may compare strings with integers as well. The python comparison logic is
used:

    >>> r = ea([(a, b), (a, c)], 'offset', 5, '>')
    >>> len(r) == 1 and r[0] == (a, c)
    True

    >>> r = ea([(a, b), (a, c)], 'string', 5, '>')
    >>> len(r) == 1 and r[0] == (a, c)
    True

KCJoin
======

KCJoin builts for a list of elements those paths with a maximal length and the
returns a list of the last element of those paths. If you specify the "?"
occurence operator, it only returns those elements with paths of len == 1.

First init the KCJoin:

    >>> from gocept.objectquery.querysupport import KCJoin
    >>> dbroot.clear()
    >>> transaction.commit()
    >>> si = StructureIndex(dbroot)
    >>> kc = KCJoin(si)

Insert some values. Two trees: (1, 2, 3, 4, 5) and (1, 6, 7):

    >>> si.insert(1)
    >>> si.insert(2, 1)
    >>> si.insert(3, 2)
    >>> si.insert(4, 3)
    >>> si.insert(5, 4)
    >>> si.insert(6, 1)
    >>> si.insert(7, 6)

Get a Kleene Closure over 4, 3, 6, 2, 5 and 7:

    >>> r = kc([(4, 4), (3, 3), (6, 6), (2, 2), (5, 5), (7, 7)], "*")
    >>> sorted(r)
    [(None, None), (2, 2), (2, 3), (2, 4), (2, 5), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5), (5, 5), (6, 6), (6, 7), (7, 7)]
    >>> r = kc([(2, 2), (3, 3), (4, 4), (5, 5)], "*")
    >>> sorted(r)
    [(None, None), (2, 2), (2, 3), (2, 4), (2, 5), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5), (5, 5)]

Get all paths with a length of zero or one within the elements 2, 3, 4, 5:

    >>> sorted(kc([(2, 2), (3, 3), (4, 4), (5, 5)], "?"))
    [(None, None), (2, 2), (3, 3), (4, 4), (5, 5)]
