==================
Using QuerySupport
==================

ObjectParser
============

Initialization
--------------

ObjectParser looks inside objects for attributes and following objects. First
we create such an object:

    >>> class Child(object):
    ...     pass

    >>> class ToParse(object):
    ...     def __init__(self):
    ...         self.some_var = ["some tupel", Child()]
    ...         self._private_var = 10
    ...         self.desc = Child()
    ...
    ...     def some_method(self):
    ...         pass

    >>> obj = ToParse()

You get an ObjectParser like this:

    >>> from gocept.objectquery.querysupport import ObjectParser
    >>> op = ObjectParser()
    >>> op
    <gocept.objectquery.querysupport.ObjectParser object at 0x...>

To parse an object, use the parse method:

    >>> op.parse(obj)

To get all found attributes, use the result() method:

    >>> op.result("attributes")
    ['some_var', '_private_var', 'desc']

    >>> descendants = op.result("descendants")
    >>> descendants
    [<Child object at 0x...>, <Child object at 0x...>]
    >>> len(descendants)
    2

EEJoin
======

Initialization
--------------

Import and create a ZODB to store the indexes:

    >>> from ZODB import FileStorage, DB
    >>> from persistent import Persistent
    >>> import transaction
    >>> storage = FileStorage.FileStorage('/tmp/test-querysupport.fs')
    >>> db = DB(storage)
    >>> conn = db.open()
    >>> dbroot = conn.root()
    >>> dbroot.clear()
    >>> transaction.commit()

EEJoin (Element-Element-Join) joins two lists with the help of the
StructureIndex. First we need a StructureIndex and the EEJoin:

    >>> from gocept.objectquery.indexsupport import StructureIndex
    >>> from gocept.objectquery.querysupport import EEJoin
    >>> si = StructureIndex(dbroot)
    >>> eejoin = EEJoin(si)

Fill the StructureIndex with data:

    >>> si.insert(1)
    >>> si.insert(2, 1)
    >>> si.insert(3, 1)
    >>> si.insert(2, 3)
    >>> si.insert(4, 2)
    >>> si.insert(5, 1)
    >>> si.insert(4, 5)

A simple query. Which out of 2, 3 and 4 is reachable by 5:

    >>> eejoin([5], [2, 3, 4])
    [4]

Some related queries:

    >>> eejoin([1], [1])
    []
    >>> eejoin([5], [1])
    []
    >>> eejoin([1], [1, 2, 3, 4, 5])
    [2, 3, 4, 5]

You may also find all x, which are directly reachable (without any steps
between x and y) by providing the ``direct'' flag:

    >>> eejoin([1], [1, 2, 3, 4, 5], direct=True)
    [2, 3, 5]

Duplicate results are well ignored:

    >>> eejoin([1, 2], [1, 2, 3, 4, 5], direct=True)
    [2, 3, 4, 5]

Furthermore it is possible to specify a subindex. Then only those elements
reachable within this subindex are returned:

    >>> eejoin([1], [1, 2, 3, 4, 5], subindex=[(1, 5)])
    [4, 5]
    >>> eejoin([1], [1, 2, 3, 4, 5], subindex=[(1, 5), (1, 3)])
    [2, 3, 4, 5]

Of course, duplicates are ignored as well:

    >>> eejoin([1], [1, 2, 3, 4, 5], subindex=[(1, 5), (1, 3), (1, 3, 2)])
    [2, 3, 4, 5]

EAJoin
======

The EAJoin joins two lists of objects. The first list holds all objects which
match the element condition in a PathExpression query. The second list holds
all objects which match the attribute and value condition (predicate)
evaluated by the ObjectCollection.

Here some example use-cases:

    >>> from gocept.objectquery.querysupport import EAJoin
    >>> ea = EAJoin()
    >>> ea([1, 2, 3], [1, 2])
    [1, 2]
    >>> ea([1, 2, 3], [4, 5])
    []
    >>> ea([1, 2, 3], [2, 4, 5])
    [2]

KCJoin
======

KCJoin builts for a list of elements those paths with a maximal length and the
returns a list of the last element of those paths. If you specify the "?"
occurence operator, it only returns those elements with paths of len == 1.

First init the KCJoin:

    >>> from gocept.objectquery.querysupport import KCJoin
    >>> dbroot.clear()
    >>> transaction.commit()
    >>> si = StructureIndex(dbroot)
    >>> kc = KCJoin(si)

Insert some values. Two trees: (1, 2, 3, 4, 5) and (1, 6):

    >>> si.insert(1)
    >>> si.insert(2, 1)
    >>> si.insert(3, 2)
    >>> si.insert(4, 3)
    >>> si.insert(5, 4)
    >>> si.insert(6, 1)

Get all elements, which are reachable over 1, 4, 2, 6, 2 or 5:

    >>> kc([1, 4, 3, 6, 2, 5], "*")
    [6, 5]
    >>> kc([1, 2, 3, 4, 5], "*")
    [5]

There are no paths with a length of 1 within the elements 1, 2, 3, 4, 5:

    >>> kc([1, 2, 3, 4, 5], "?")
    []

But element 6 is the only one within 6, 3, 4:

    >>> kc([6, 3, 4], "?")
    [6]
