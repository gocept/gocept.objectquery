======================
Using ObjectCollection
======================

Initialization
==============

First we need a ZODB for the IndexSupport used by ObjectCollection:

    >>> from ZODB import MappingStorage, DB
    >>> from persistent import Persistent
    >>> import transaction
    >>> storage = MappingStorage.MappingStorage()
    >>> db = DB(storage)
    >>> conn = db.open()
    >>> dbroot = conn.root()

Then we need some testobjects, which we will store into the ObjectCollection:

    >>> from gocept.objectquery import testobjects

Imporing the ObjectCollection
=============================

You can import the QueryParser as follow:

    >>> from gocept.objectquery.collection import ObjectCollection

Get a ObjectCollection:

    >>> oc = ObjectCollection(conn)

Using the ObjectCollection
==========================


Example usage of ObjectCollection
---------------------------------

Add some objects to the collection:

    >>> t1 = testobjects.Telephone(number="22")
    >>> t2 = testobjects.Telephone(number="66")
    >>> p1 = testobjects.Person(name="Sebastian")
    >>> a1 = testobjects.Address(street="Meckelstrasse", city="Halle")
    >>> dbroot['test'] = a1
    >>> transaction.commit()

    >>> oc.add(a1)
    >>> oc.root()[0] == a1._p_oid
    True

    >>> a1.ref.append(p1)
    >>> transaction.commit()
    >>> oc.add(p1, a1._p_oid)

    >>> p1.work.append(t1)
    >>> p1.work.append(t2)
    >>> transaction.commit()
    >>> oc.add(t1, p1._p_oid)
    >>> oc.add(t2, p1._p_oid)


Verify the indexes:

    >>> result = list(oc._classindex.get("Telephone"))
    >>> conn.get(result[0])
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> conn.get(result[1])
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> result = list(oc._attributeindex.get("name"))
    >>> conn.get(result[0])
    <gocept.objectquery.testobjects.Person object at 0x...>
    >>> conn.get(result[1])
    Traceback (most recent call last):
    ...
    IndexError: list index out of range


Search by classname:

    >>> r = oc.by_class("Telephone")
    >>> conn.get(r[0][0])
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> conn.get(r[1][0])
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> r = oc.by_class("Address")
    >>> conn.get(r[0][0])
    <gocept.objectquery.testobjects.Address object at 0x...>


Adding and removing objects:
----------------------------

Adding some more objects to ``oc``:

    >>> p2 = testobjects.Person(name="Christian")
    >>> a1.ref.append(p2)
    >>> transaction.commit()

    >>> oc.add(p2, a1._p_oid)
    >>> len(oc.by_class("Person"))
    2

    >>> t3 = testobjects.Telephone(number="2298891")
    >>> p2.work.append(t3)
    >>> transaction.commit()

    >>> oc.add(t3, p2._p_oid)
    >>> len(oc.by_class("Telephone"))
    3

Verify the correct insertions:

    >>> oc.is_child(t3._p_oid, p1._p_oid)
    False
    >>> oc.is_child(t3._p_oid, p2._p_oid)
    True

Successful removing:

    >>> p1.work.remove(t1)
    >>> oc.delete(t1._p_oid, p1._p_oid)
    >>> transaction.commit()
    >>> len(oc.by_class("Telephone"))
    2

    >>> oc.delete(p2._p_oid)
    >>> a1.ref.remove(p2)
    >>> transaction.commit()
    >>> len(oc.by_class("Person"))
    1
    >>> len(oc.by_class("Telephone"))
    1

Adding circles to collection
----------------------------

First we need a new ObjectCollection:

    >>> dbroot.clear()
    >>> transaction.commit()
    >>> oc = ObjectCollection(conn)

Then create two objects and add one under the other:

    >>> add = testobjects.Address()
    >>> per = testobjects.Person()

    >>> dbroot['test'] = add
    >>> transaction.commit()
    >>> oc.add(add)

    >>> add.ref.append(per)
    >>> transaction.commit()
    >>> oc.add(per, add._p_oid)

There are now no Telephone objects inside the ObjectCollection:

    >>> len(oc.by_class("Telephone"))
    0

Adding add under per will create a cycle, which is possible at all:

    >>> per.ref.append(add)
    >>> transaction.commit()
    >>> oc.add(per, add._p_oid)

To test the cycle, per should be a child of add and vice versa:

    >>> oc.is_child(per._p_oid, add._p_oid)
    True
    >>> oc.is_child(add._p_oid, per._p_oid)
    True

Adding and Removing multiple objects
------------------------------------

First we need a new ObjectCollection:

    >>> dbroot.clear()
    >>> transaction.commit()
    >>> oc = ObjectCollection(conn)

Then create some objects and add them:

    >>> add = testobjects.Address()
    >>> per1 = testobjects.Person()
    >>> per2 = testobjects.Person()
    >>> tel = testobjects.Telephone()

Telephone now ``hangs'' under two objects, Person1 and Person2:

    >>> add.ref.append(per1)
    >>> add.ref.append(per2)
    >>> per1.ref.append(tel)
    >>> per2.ref.append(tel)

    >>> dbroot['test'] = add
    >>> transaction.commit()
    >>> oc.add(add)

Now there are 2 Person and 1 Telephone object:

    >>> len(oc.by_class("Person"))
    2
    >>> len(oc.by_class("Telephone"))
    1

But Telephone is the child of Person1 *and* Person2:

    >>> oc.is_child(tel._p_oid, per1._p_oid)
    True
    >>> oc.is_child(tel._p_oid, per2._p_oid)
    True

Removing Person1 will not cause the deletion of Telephone (because it still
does exist under Person2):

    >>> oc.delete(per1._p_oid)
    >>> add.ref.remove(per1)
    >>> transaction.commit()

Now there is only one Person object, but still one Telephone:

    >>> len(oc.by_class("Person"))
    1
    >>> len(oc.by_class("Telephone"))
    1


Automatic index updates on transaction boundaries
=================================================

When making changes to objects, the index can be updated at transaction
boundaries automatically for all objects that where changed.

A synchronizer needs to be registered with the transaction manager first and
the object collection needs to be registered as a utility:

    >>> from gocept.objectquery import indexsupport
    >>> index_synch = indexsupport.IndexSynchronizer()
    >>> transaction.manager.registerSynch(index_synch)
    >>> import zope.component
    >>> zope.component.provideUtility(oc)

    >>> dbroot['add2'] = testobjects.Address()
    >>> transaction.commit()
    >>> len(oc.by_class("Address"))
    2

Automatic updates stop when disabling the index synchronizer again:

    >>> transaction.manager.unregisterSynch(index_synch)
