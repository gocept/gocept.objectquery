======================
Using ObjectCollection
======================

Initialization
==============

First we need a ZODB for the IndexSupport used by ObjectCollection:

    >>> from ZODB import FileStorage, DB
    >>> from persistent import Persistent
    >>> import transaction
    >>> storage = FileStorage.FileStorage('/tmp/test-collection.fs')
    >>> db = DB(storage)
    >>> conn = db.open()
    >>> dbroot = conn.root()

Purge old data:

    >>> dbroot.clear()
    >>> transaction.commit()

Then we need some testobjects, which we will store into the ObjectCollection:

    >>> import gocept.objectquery.testobjects as testobject

Imporing the ObjectCollection
=============================

You can import the QueryParser as follow:

    >>> from gocept.objectquery.collection import ObjectCollection

Get a ObjectCollection:

    >>> oc = ObjectCollection(conn)

Using the ObjectCollection
==========================

Example usage of ObjectCollection
---------------------------------

Add some objects to the collection:

    >>> t1 = testobject.Telephone(number="22")
    >>> t2 = testobject.Telephone(number="66")
    >>> p1 = testobject.Person(name="Sebastian", work=[t1, t2])
    >>> a1 = testobject.Address(street="Meckelstrasse", city="Halle", ref=[p1])
    >>> dbroot['test'] = a1
    >>> transaction.commit()

    >>> oc.add(a1._p_oid)
    >>> oc.root() == a1._p_oid
    True

Verify the indexes:

    >>> result = oc._classindex.get("Telephone")
    >>> conn.get(result[0])
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> conn.get(result[1])
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> result = oc._attributeindex.get("name")
    >>> conn.get(result[0])
    <gocept.objectquery.testobjects.Person object at 0x...>
    >>> conn.get(result[1])
    Traceback (most recent call last):
    ...
    IndexError: list index out of range

The method get_structureindex returns the StructureIndex for a given key:

    >>> result = oc.get_structureindex(t1._p_oid)[0]
    >>> conn.get(result[0])
    <gocept.objectquery.testobjects.Address object at 0x...>
    >>> conn.get(result[1])
    <gocept.objectquery.testobjects.Person object at 0x...>
    >>> conn.get(result[2])
    <gocept.objectquery.testobjects.Telephone object at 0x...>

Search by classname:

    >>> r = oc.by_class("Telephone")
    >>> conn.get(r[0])
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> conn.get(r[1])
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> r = oc.by_class("Address")
    >>> conn.get(r[0])
    <gocept.objectquery.testobjects.Address object at 0x...>

Now search for some object attributes:

    >>> r = oc.by_attr("number", "22")
    >>> conn.get(r[0])
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> r = oc.by_attr("street", "", "=")
    >>> r
    []
    >>> r = oc.by_attr("street", "", "!=")
    >>> conn.get(r[0])
    <gocept.objectquery.testobjects.Address object at 0x...>
    >>> r = oc.by_attr("number", "33", "<")
    >>> len(r)
    1
    >>> conn.get(r[0]).number
    '22'
    >>> r = oc.by_attr("number", "66", ">=")
    >>> len(r)
    1
    >>> conn.get(r[0]).number
    '66'
    >>> r = oc.by_attr("number", "66", ">")
    >>> len(r)
    0

Exceptions are raised if the comparison operator is not supported...:

    >>> r = oc.by_attr("number", "True", "not")
    Traceback (most recent call last):
    ...
    KeyError: 'not'

... or the comparison value can not be casted into a legal type:

    >>> r = oc.by_attr("street", "mystreet", "<")
    Traceback (most recent call last):
    ...
    ValueError: invalid literal for float(): ...

Adding and removing objects:
----------------------------

Adding some more objects to ``oc``:

    >>> p2 = testobject.Person(name="Christian")
    >>> a1.ref.append(p2)
    >>> transaction.commit()

    >>> oc.add(p2._p_oid, a1._p_oid)
    >>> len(oc.by_class("Person"))
    2

    >>> t3 = testobject.Telephone(number="2298891")
    >>> p2.work.append(t3)
    >>> transaction.commit()

    >>> oc.add(t3._p_oid, p2._p_oid)
    >>> len(oc.by_class("Telephone"))
    3

Verify the correct insertions:

    >>> oc.is_child(t3._p_oid, p1._p_oid)
    False
    >>> oc.is_child(t3._p_oid, p2._p_oid)
    True
    >>> oc.is_successor(a1._p_oid, t3._p_oid)
    False
    >>> oc.is_successor(t1._p_oid, a1._p_oid)
    True

Successful removing:

    >>> oc.delete(t1._p_oid, p1._p_oid)
    >>> p1.work.remove(t1)
    >>> transaction.commit()
    >>> len(oc.by_class("Telephone"))
    2

    >>> oc.delete(p2._p_oid)
    >>> a1.ref.remove(p2)
    >>> transaction.commit()
    >>> len(oc.by_class("Telephone"))
    1
    >>> len(oc.by_class("Person"))
    1

Adding circles to collection
----------------------------

First we need a new ObjectCollection:

    >>> dbroot.clear()
    >>> transaction.commit()
    >>> oc = ObjectCollection(conn)

Then create two objects and add one under the other:

    >>> add = testobject.Address()
    >>> per = testobject.Person()

    >>> dbroot['test'] = add
    >>> transaction.commit()
    >>> oc.add(add._p_oid)

    >>> add.ref.append(per)
    >>> transaction.commit()
    >>> oc.add(per._p_oid, add._p_oid)

Adding add unter per will create a cycle, which is possible at all:

    >>> per.ref.append(add)
    >>> transaction.commit()
    >>> oc.add(per._p_oid, add._p_oid)

To test the cycle, per should be a child of add and vice versa:

    >>> oc.is_child(per._p_oid, add._p_oid)
    True
    >>> oc.is_child(add._p_oid, per._p_oid)
    True

Adding and Removing multiple objects
------------------------------------

First we need a new ObjectCollection:

    >>> dbroot.clear()
    >>> transaction.commit()
    >>> oc = ObjectCollection(conn)

Then create some objects and add them:

    >>> add = testobject.Address()
    >>> per1 = testobject.Person()
    >>> per2 = testobject.Person()
    >>> tel = testobject.Telephone()

Telephone now ``hangs'' under two objects, Person1 and Person2:

    >>> add.ref.append(per1)
    >>> add.ref.append(per2)
    >>> per1.ref.append(tel)
    >>> per2.ref.append(tel)

    >>> dbroot['test'] = add
    >>> transaction.commit()
    >>> oc.add(add._p_oid)

Now there are 2 Person and 1 Telephone object:

    >>> len(oc.by_class("Person"))
    2
    >>> len(oc.by_class("Telephone"))
    1

But Telephone is the child of Person1 *and* Person2:

    >>> oc.is_child(tel._p_oid, per1._p_oid)
    True
    >>> oc.is_child(tel._p_oid, per2._p_oid)
    True

Removing Person1 will not cause the deletion of Telephone (because it still
does exist under Person2):

    >>> oc.delete(per1._p_oid)
    >>> add.ref.remove(per1)
    >>> transaction.commit()

Now there is only one Person object, but still one Telephone:

    >>> len(oc.by_class("Person"))
    1
    >>> len(oc.by_class("Telephone"))
    1
