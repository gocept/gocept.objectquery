======================
Using ObjectCollection
======================

Initialization
==============

First we need a ZODB for the IndexSupport used by ObjectCollection:

    >>> from ZODB import MappingStorage, DB
    >>> from persistent import Persistent
    >>> import transaction
    >>> storage = MappingStorage.MappingStorage()
    >>> db = DB(storage)
    >>> conn = db.open()
    >>> dbroot = conn.root()

Then we need some testobjects, which we will store into the ObjectCollection:

    >>> from gocept.objectquery import testobjects

Imporing the ObjectCollection
=============================

You can import the QueryParser as follow:

    >>> from gocept.objectquery.collection import ObjectCollection

Get a ObjectCollection:

    >>> oc = ObjectCollection(conn)

Using the ObjectCollection
==========================


Adding items to the ObjectCollection
------------------------------------

Before you can start, you should add objects to the collection. In most cases,
it is sufficient to add the root object of your database. The collection will
index all objects referenced by this root object recursively by its own.

First of all, we create some objects for our test-database:

    >>> t1 = testobjects.Telephone(number=22)
    >>> t2 = testobjects.Telephone(number=66)
    >>> p1 = testobjects.Person(name="Sebastian")
    >>> a1 = testobjects.Address(street="Meckelstrasse", city="Halle")

Now we create a hierachy between those objects and add them to the ZODB. Don't
forget to commit the transaction, because the ObjectCollection needs the OID of
your peristant objects for internal storage:

    >>> a1.ref.append(p1)
    >>> p1.work.extend((t1, t2))
    >>> dbroot['test'] = a1
    >>> transaction.commit()

To index our test-db, we add the root object to the ObjectCollection. For large
databases, this process can last some time:

    >>> oc.add(dbroot['test'])


Internal representation of the indexes
--------------------------------------

The ObjectCollection has a index called ClassIndex, which is a mapping of
classnames to OIDs of this class. It returns a generator object with all found
results.

We added two Telephone objects to the database:

    >>> phones = oc._classindex.get("Telephone")
    >>> phones
    <generator object at 0x...>
    
    >>> phones = list(phones)
    >>> len(phones)
    2

As shortly mentioned above, the ObjectCollection stores OID instead of objects.
To have a look at these objects, we have to ask the connection object:

    >>> res_phone1 = conn.get(phones[0])
    >>> res_phone1
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> res_phone2 = conn.get(phones[1])
    >>> res_phone2
    <gocept.objectquery.testobjects.Telephone object at 0x...>
    >>> res_phone1 == res_phone2
    False

There is also an index available, which maps attribute names to OIDs of
classes, which have that attribute. It returns a generator object, too:

    >>> names = oc._attributeindex.get("name")
    >>> names
    <generator object at 0x...>

    >>> names = list(names)
    >>> len(names)
    1
    >>> basti = conn.get(names[0])
    >>> basti
    <gocept.objectquery.testobjects.Person object at 0x...>
    >>> basti.name
    'Sebastian'


Adding some more objects to the ObjectCollection
------------------------------------------------

Adding some more objects to ``oc``. This is done in the same way as mentioned
above:

    >>> p2 = testobjects.Person(name="Christian")
    >>> a1.ref.append(p2)
    >>> transaction.commit()
    >>> oc.add(p2, a1)

There are now two person objects inside the database:

    >>> len(oc.by_class("Person"))
    2

Now Christian gets a telephone number:

    >>> t3 = testobjects.Telephone(number="2298891")
    >>> p2.work.append(t3)
    >>> transaction.commit()
    >>> oc.add(t3, p2)

There are now three telephone numbers available:

    >>> len(oc.by_class("Telephone"))
    3


Testing the database hierarchie
-------------------------------

To test, wheather an object is a child of another or not, the ObjectCollection
uses another index for performance reason, the structure index. It returns the
result independent from the depth of the graph and the distance of the two
objects.

    >>> oc.is_child(t3._p_oid, p1._p_oid)
    False
    >>> oc.is_child(t3._p_oid, p2._p_oid)
    True

Removing objects from the ObjectCollection
------------------------------------------

When removing objects, all child objects, which are no longer referenced by
others, are removed as well.

    >>> p1.work.remove(t1)
    >>> oc.delete(t1._p_oid)
    >>> transaction.commit()

There are two phones remaining:

    >>> len(oc.by_class("Telephone"))
    2

When removing a person, all its telephones are removed, too:

    >>> a1.ref.remove(p2)
    >>> oc.delete(p2._p_oid)
    >>> transaction.commit()
    >>> len(oc.by_class("Person"))
    1
    >>> len(oc.by_class("Telephone"))
    1


Adding circles to collection
----------------------------

It is possible, to add circle references to a ObjectCollection. First we need
a new ObjectCollection:

    >>> dbroot.clear()
    >>> transaction.commit()
    >>> oc = ObjectCollection(conn)

Then create two objects and add one under the other:

    >>> add = testobjects.Address()
    >>> per = testobjects.Person()

    >>> dbroot['test'] = add
    >>> transaction.commit()
    >>> oc.add(add)

    >>> add.ref.append(per)
    >>> transaction.commit()
    >>> oc.add(per, add)

There are now no Telephone objects inside the ObjectCollection:

    >>> len(oc.by_class("Telephone"))
    0

Furthermore, Person is a child of Address, but Address is no child of Person:

    >>> oc.is_child(per._p_oid, add._p_oid)
    True
    >>> oc.is_child(add._p_oid, per._p_oid)
    False

Adding Address under Person will create a cycle, which is possible at all:

    >>> per.ref.append(add)
    >>> transaction.commit()
    >>> oc.add(per, add)

To test the cycle, Person should be a child of Address and vice versa:

    >>> oc.is_child(per._p_oid, add._p_oid)
    True
    >>> oc.is_child(add._p_oid, per._p_oid)
    True

Adding and Removing multiple objects
------------------------------------

First we need a new ObjectCollection:

    >>> dbroot.clear()
    >>> transaction.commit()
    >>> oc = ObjectCollection(conn)

Then create some objects and add them:

    >>> add = testobjects.Address()
    >>> per1 = testobjects.Person()
    >>> per2 = testobjects.Person()
    >>> tel = testobjects.Telephone()

Telephone now 'hangs' under two objects, Person1 and Person2:

    >>> add.ref.append(per1)
    >>> add.ref.append(per2)
    >>> per1.ref.append(tel)
    >>> per2.ref.append(tel)

    >>> dbroot['test'] = add
    >>> transaction.commit()
    >>> oc.add(add)

Now there are 2 Person and 1 Telephone object:

    >>> len(oc.by_class("Person"))
    2
    >>> len(oc.by_class("Telephone"))
    1

But Telephone is the child of Person1 *and* Person2:

    >>> oc.is_child(tel._p_oid, per1._p_oid)
    True
    >>> oc.is_child(tel._p_oid, per2._p_oid)
    True

Removing Person1 will not cause the deletion of Telephone (because it still
does exist under Person2):

    >>> oc.delete(per1._p_oid)
    >>> add.ref.remove(per1)
    >>> transaction.commit()

Now there is only one Person object, but still one Telephone:

    >>> len(oc.by_class("Person"))
    1
    >>> len(oc.by_class("Telephone"))
    1


Automatic index updates on transaction boundaries
=================================================

When making changes to objects, the index can be updated at transaction
boundaries automatically for all objects that where changed.

A synchronizer needs to be registered with the transaction manager first and
the object collection needs to be registered as a utility:

    >>> from gocept.objectquery import indexsupport
    >>> index_synch = indexsupport.IndexSynchronizer()
    >>> transaction.manager.registerSynch(index_synch)
    >>> import zope.component
    >>> zope.component.provideUtility(oc)

    >>> dbroot['add2'] = testobjects.Address()
    >>> transaction.commit()
    >>> len(oc.by_class("Address"))
    2

Automatic updates stop when disabling the index synchronizer again:

    >>> transaction.manager.unregisterSynch(index_synch)
