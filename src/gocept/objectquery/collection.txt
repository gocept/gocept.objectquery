======================
Using ObjectCollection
======================

Initialization
==============

First we need a ZODB for the IndexSupport used by ObjectCollection:

    >>> from ZODB import MappingStorage, DB
    >>> from persistent import Persistent
    >>> import transaction
    >>> storage = MappingStorage.MappingStorage()
    >>> db = DB(storage)
    >>> conn = db.open()
    >>> dbroot = conn.root()

Then we need some testobjects, which we will store into the ObjectCollection:

    >>> from gocept.objectquery import testobjects

Imporing the ObjectCollection
=============================

You can import the QueryParser as follow:

    >>> from gocept.objectquery.collection import ObjectCollection

Get a ObjectCollection:

    >>> oc = ObjectCollection(conn)

Using the ObjectCollection
==========================


Adding items to the ObjectCollection
------------------------------------

Before you can start, you should add objects to the collection. In most cases,
it is sufficient to add the root object of your database. The collection will
index all objects referenced by this root object recursively by its own.

First of all, we create some objects for our test-database:

    >>> hans = testobjects.Person(name="Hans")
    >>> marie = testobjects.Person(name="Marie")
    >>> zodb_book = testobjects.Book(
    ...                 authors=[],
    ...                 title='Ad-hoc Anfragen an die ZODB',
    ...                 written=2004,
    ...                 isbn=3404159063)
    >>> halle = testobjects.Library(location="Halle")

Now we create a hierachy between those objects and add them to the ZODB. Don't
forget to commit the transaction, because the ObjectCollection needs the OID of
your peristant objects for internal storage:

    >>> zodb_book.authors.extend([hans, marie])
    >>> halle.books.append(zodb_book)
    >>> dbroot['test'] = halle
    >>> transaction.commit()

To index our test-db, we add the root object to the ObjectCollection. For large
databases, this process can last some time:

    >>> oc.add(dbroot['test'])


Internal representation of the indexes
--------------------------------------

The ObjectCollection has a index called ClassIndex, which is a mapping of
classnames to OIDs of this class. It returns a generator object with all found
results.

We added two Person objects to the database:

    >>> persons = oc._classindex.get("Person")
    >>> persons
    <generator object at 0x...>
    
    >>> persons = list(persons)
    >>> len(persons)
    2

As shortly mentioned above, the ObjectCollection stores OID instead of objects.
To have a look at these objects, we have to ask the connection object:

    >>> person1 = conn.get(persons[0])
    >>> person1
    <gocept.objectquery.testobjects.Person object at 0x...>
    >>> person2 = conn.get(persons[1])
    >>> person2
    <gocept.objectquery.testobjects.Person object at 0x...>

    >>> person1 == hans 
    True
    >>> person2 == marie
    True
    >>> person1 == person2
    False

There is also an index available, which maps attribute names to OIDs of
classes, which have that attribute. It returns a generator object, too:

    >>> names = oc._attributeindex.get("name")
    >>> names
    <generator object at 0x...>

    >>> names = list(names)
    >>> len(names)
    2
    >>> hans = conn.get(names[0])
    >>> hans.name
    'Hans'
    >>> marie = conn.get(names[1])
    >>> marie.name
    'Marie'


Adding some more objects to the ObjectCollection
------------------------------------------------

Lets add some more objects to the collection. This is done in the same way as
mentioned above:

    >>> zope_book = testobjects.Book(
    ...         authors=[hans],
    ...         title='Zope in action',
    ...         written=2003,
    ...         isbn=123456789)
    >>> halle.books.append(zope_book)
    >>> transaction.commit()
    >>> oc.add(zope_book, halle)        # XXX: should be obsolete soon

There are now two books inside the database:

    >>> len(oc.by_class("Book"))
    2

The Zope book now gets a second author:

    >>> mark = testobjects.Person(name='Mark')
    >>> zope_book.authors.append(mark)
    >>> transaction.commit()
    >>> oc.add(mark, zope_book)         # XXX: should be obsolete soon

There are now three persons available:

    >>> len(oc.by_class("Person"))
    3


Testing the database hierarchie
-------------------------------

To test, wheather an object is a child of another or not, the ObjectCollection
uses another index for performance reason, the structure index. It returns the
result independent from the depth of the graph and the distance of the two
objects. Because it is only used internally, we must provide the OIDs here
instead of objects:

    >>> oc.is_child(zope_book._p_oid, mark._p_oid)
    False
    >>> oc.is_child(mark._p_oid, zope_book._p_oid)
    True
    >>> oc.is_child(mark._p_oid, zodb_book._p_oid)
    False


Removing objects from the ObjectCollection
------------------------------------------

When removing objects, all child objects, which are no longer referenced by
others, are removed as well.

    >>> zope_book.authors.remove(mark)
    >>> oc.delete(mark._p_oid)          # XXX: should be obsolete soon
    >>> transaction.commit()

There are two persons remaining:

    >>> len(oc.by_class("Person"))
    2

When removing a book, all its authors are removed, too, *if* there are no more
books left, which they wrote:

    >>> halle.books.remove(zodb_book)
    >>> oc.delete(zodb_book._p_oid)
    >>> transaction.commit()
    >>> len(oc.by_class("Person"))
    1
    >>> len(oc.by_class("Book"))
    1


Automatic index updates on transaction boundaries
-------------------------------------------------

When making changes to objects, the index can be updated at transaction
boundaries automatically for all objects that where changed.

A synchronizer needs to be registered with the transaction manager first and
the object collection needs to be registered as a utility:

    >>> from gocept.objectquery import indexsupport
    >>> index_synch = indexsupport.IndexSynchronizer()
    >>> transaction.manager.registerSynch(index_synch)
    >>> import zope.component
    >>> zope.component.provideUtility(oc)

    >>> dbroot['person'] = testobjects.Person(name='Christian')
    >>> transaction.commit()
    >>> len(oc.by_class("Person"))
    2

But what still does not work, is adding objects under existing ones:

    >>> zope_book.authors.append(mark)
    >>> transaction.commit()

Mark is now added (thats good, of course):

    >>> len(oc.by_class("Person"))
    3

But he is not added as a child of the zope_book (which is bad):

    >>> oc.is_child(mark._p_oid, zope_book._p_oid)
    False

Automatic updates stop when disabling the index synchronizer again:

    >>> transaction.manager.unregisterSynch(index_synch)


Adding circles to collection
----------------------------

It is possible, to add circle references to a ObjectCollection. First we need
a new ObjectCollection:

    >>> dbroot.clear()
    >>> transaction.commit()
    >>> oc = ObjectCollection(conn)

Then create two objects and add one under the other:

    >>> first = testobjects.Dummy(id=1)
    >>> second = testobjects.Dummy(id=2)

    >>> dbroot['test'] = first
    >>> transaction.commit()
    >>> oc.add(first)                   # XXX: should be obsolete soon

    >>> first.ref.append(second)
    >>> transaction.commit()
    >>> oc.add(second, first)           # XXX: should be obsolete soon

There are now no Telephone objects inside the ObjectCollection:

    >>> len(oc.by_class("Telephone"))
    0

Furthermore, second is a child of first, but first is no child of second:

    >>> oc.is_child(second._p_oid, first._p_oid)
    True
    >>> oc.is_child(first._p_oid, second._p_oid)
    False

Adding first under second will create a cycle, which is possible at all:

    >>> second.ref.append(first)
    >>> transaction.commit()
    >>> oc.add(first, second)           # XXX: should be obsolete soon

To test the cycle, second should be a child of first and vice versa:

    >>> oc.is_child(second._p_oid, first._p_oid)
    True
    >>> oc.is_child(first._p_oid, second._p_oid)
    True


