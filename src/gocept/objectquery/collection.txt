======================
Using ObjectCollection
======================

Imporing the ObjectCollection
=============================

You can import the QueryParser as follow:

    >>> from gocept.objectquery.collection import ObjectCollection

Get a ObjectCollection:

    >>> oc = ObjectCollection()

PathIndex
=========

First get a PathIndex object:

    >>> from gocept.objectquery.collection import PathIndex
    >>> pi = PathIndex()

PathIndex has a list named path, which is empty for the root PathIndex:

    >>> pi
    <....PathIndex object with path ''>

With the Method ``bear`` you can add a new PathIndex under your
PathIndex-Object. The path can be any object you like:

    >>> pi1 = pi.bear("foo")
    >>> pi1
    <... 'foo'>

    >>> pi2 = pi.bear(1408)
    >>> pi2
    <... '1408'>

    >>> class MyClass(object):
    ...     pass
    >>> pi11 = pi1.bear(MyClass())
    >>> pi11
    <... 'foo, <MyClass object at 0x...>'>

You can test the relationship by using the contains method ``in``:

    >>> pi in pi
    False
    >>> pi1 in pi
    True
    >>> pi11 in pi
    True
    >>> pi11 in pi2
    False
    >>> pi1 in pi2
    False
    >>> pi2 in pi
    True

You may also ask, if parent has a direct relationship to child (there are no
other nodes between parent and child):

    >>> pi.is_direct_parent(pi1)
    True
    >>> pi1.is_direct_parent(pi11)
    True
    >>> pi.is_direct_parent(pi11)
    False

Using the ObjectCollection
==========================

How to add objects to the ObjectCollection
------------------------------------------

ObjectCollection is looking inside objects for other objects. You have the
following possibilities to add preceding objects.

    >>> class Child(object):
    ...     pass

Tupels:

    >>> class Parent(object):
    ...     def __init__(self):
    ...         self.ref_tupel = (Child(), Child())
    >>> obj = Parent()
    >>> oc.index(obj)
    >>> oc.remove(obj, oc.root()[0])

Lists:

    >>> class Parent(object):
    ...     def __init__(self):
    ...         self.ref_list = [Child(), Child()]
    >>> obj = Parent()
    >>> oc.index(obj)
    >>> oc.remove(obj, oc.root()[0])

Dictionaries:

    >>> class Parent(object):
    ...     def __init__(self):
    ...         self.ref_dict = {"elem1": Child(), "elem2": Child()}
    >>> obj = Parent()
    >>> oc.index(obj)
    >>> oc.remove(obj, oc.root()[0])

Variables:

    >>> class Parent(object):
    ...     def __init__(self):
    ...         self.ref_var = Child()
    >>> obj = Parent()
    >>> oc.index(obj)
    >>> oc.remove(obj, oc.root()[0])

Example usage of ObjectCollection
---------------------------------

First create some example classes. All have the attribute "__ns__" which is
a namespace tupel which consists of (order, size) variables.

    >>> class Telephone(object):
    ...     def __init__(self, number="", ref=None):
    ...         if ref is None:
    ...           ref = []
    ...         self.ref = ref
    ...         self.number = number
    >>> class Person(object):
    ...     def __init__(self, name="", ref=None):
    ...         if ref is None:
    ...           ref = []
    ...         self.ref = ref
    ...         self.name = name
    >>> class Address(object):
    ...     def __init__(self, street="", city="", ref=None):
    ...         if ref is None:
    ...           ref = []
    ...         self.ref = ref
    ...         self.street = street
    ...         self.city = city

Add some objects to the collection:

    >>> t1 = Telephone(number="22988912")
    >>> t2 = Telephone(number="22988913")
    >>> p1 = Person(name="Sebastian")
    >>> p1.ref = [t1, t2]
    >>> a1 = Address(street="Meckelstrasse", city="Halle")
    >>> a1.ref = [p1]
    >>> oc.index(a1)
    >>> oc.all()
    [<Address object at 0x...>, <Person object at 0x...>, <Telephone object at 0x...>, <Telephone object at 0x...>]

Search by classname:

    >>> oc.by_class("Telephone")
    [<Telephone object at 0x...>, <Telephone object at 0x...>]
    >>> oc.by_class("Address")
    [<Address object at 0x...>]

Now search for some object attributes:

    >>> oc.by_attr("number", "22988912")
    [<Telephone object at 0x...>]
    >>> oc.by_attr("city", "Halle")
    [<Address object at 0x...>]
    >>> oc.by_attr("street", "")
    []

You may want to get some values:

    >>> oc.get_value("street")
    ['Meckelstrasse']
    >>> oc.get_value("name")
    ['Sebastian']

Adding and removing equal objects multiple times
------------------------------------------------

First we need a new ObjectCollection:

    >>> oc2 = ObjectCollection()

Then we generate a tree structure with one Address as root, followed by two
equal Persons. Person is followed by two equal Telephones:

    >>> tele = Telephone()
    >>> pers = Person(ref=[tele, tele])
    >>> addr = Address(ref=[pers, pers])
    >>> oc2.index(addr)

Now we have 4 Telephone objects as leaves:

    >>> len(oc2._namespace[tele])
    4

Add another Telephone (the same as added above) to Person:

    >>> pers.ref.append(tele)
    >>> oc2.add(tele, pers)

Now we have 6 Telephone objects as leaves:

    >>> len(oc2._namespace[tele])
    6

Now add Address for a second time to the Collection:

    >>> oc2.index(addr)

Now we have 2 Address, 4 Person and 12 Telephone objects as leaves:

    >>> len(oc2._namespace[addr])
    2
    >>> len(oc2._namespace[pers])
    4
    >>> len(oc2._namespace[tele])
    12

Now add a third and fourth Person to Address:

    >>> addr.ref.append(pers)
    >>> oc2.add(pers, addr)
    >>> addr.ref.append(pers)
    >>> oc2.add(pers, addr)

There are now 8 Person (every 4 under Address) and 24 Telephone objects:

    >>> len(oc2._namespace[pers])
    8
    >>> len(oc2._namespace[tele])
    24

Last add a third Address into the Collection:

    >>> oc2.index(addr)

There are now 12 Person and 36 Telephone objects:

    >>> len(oc2._namespace[pers])
    12
    >>> len(oc2._namespace[tele])
    36

Add another Telephone (the same as added above) to Person:

    >>> pers.ref.append(tele)
    >>> oc2.add(tele, pers)

There are now 12 Person and 48 Telephone objects:

    >>> len(oc2._namespace[pers])
    12
    >>> len(oc2._namespace[tele])
    48

Remove the Person from Address object:

    >>> addr.ref.remove(pers)
    >>> oc2.remove(pers, addr)

As the Telephones are removed with the Persons, we now have no Telephone
leaves:

    >>> len(oc2._namespace[tele])
    Traceback (most recent call last):
    ...
    KeyError: <Telephone object at 0x...>

Dynamic namespace expansion
===========================

Dynamic namespace expansion in height
-------------------------------------

To test the dynamic namespace expansion we first need a new ObjectCollection
with a very minimal but senseful MAX_HEIGHT value:

    >>> oc3 = ObjectCollection(init_namespace=(3, 3))

We now need four classes:

    >>> class First(object):
    ...     pass
    >>> class Second(object):
    ...     pass
    >>> class Third(object):
    ...     pass
    >>> class Fourth(object):
    ...     pass

And will set them now in a hirachical order:

    >>> fir = First()
    >>> oc3.index(fir)
    >>> sec = Second()
    >>> oc3.add(sec, fir)
    >>> thi = Third()
    >>> oc3.add(thi, sec)
    >>> fou = Fourth()
    >>> oc3.add(fou, thi)

The namespace of First is a normal namespace value:

    >>> oc3._namespace[fir]
    [[(2, 8)]]

Second() has an extended namespace:

    >>> oc3._namespace[sec]
    [[(3, 1), (1, 28)]]

Third() has an extended namespace, too, within the namespace of Second():

    >>> oc3._namespace[thi]
    [[(3, 1), (2, 8)]]

Fourth() has a more extended namespace, Third() and Second():

    >>> oc3._namespace[fou]
    [[(3, 1), (3, 1), (1, 28)]]

Now that the namespace is set correctly, lets test if the comparison works.
First with unextended namespaces:

    >>> oc3._compare_namespace(oc3._namespace[fir][0],
    ...                        oc3._namespace[oc3.root()[0]][0])
    True
    >>> oc3._compare_namespace(oc3._namespace[oc3.root()[0]][0],
    ...                        oc3._namespace[fir][0])
    False

And now with an unextended and an extended namespace:

    >>> oc3._compare_namespace(oc3._namespace[sec][0],
    ...                        oc3._namespace[fir][0])
    True
    >>> oc3._compare_namespace(oc3._namespace[fir][0],
    ...                        oc3._namespace[sec][0])
    False

Last with two extended namespaces:

    >>> oc3._compare_namespace(oc3._namespace[thi][0],
    ...                        oc3._namespace[sec][0])
    True
    >>> oc3._compare_namespace(oc3._namespace[sec][0],
    ...                        oc3._namespace[thi][0])
    False

Now test the extended namespace with another not matching node:

    >>> fir2 = First()
    >>> oc3.index(fir2)
    >>> sec2 = Second()
    >>> oc3.add(sec2, fir2)
    >>> thi2 = Third()
    >>> oc3.add(thi2, sec2)

    >>> oc3._namespace[sec]
    [[(3, 1), (1, 28)]]
    >>> oc3._namespace[thi2]
    [[(12, 1), (2, 8)]]

    >>> oc3._compare_namespace(oc3._namespace[thi2][0],
    ...                        oc3._namespace[sec][0])
    False

    >>> oc3.remove(fir2, oc3.root()[0])

Dynamic namespace expansion in width
------------------------------------

The dynamic namespace expasion in width (adding more childs than initailly
set) raises an Exception:

    
    >>> for i in range(0, oc3.MAX_CHILD+1):
    ...     oc3.index(fir2)
    Traceback (most recent call last):
    ...
    ValueError: Maximum number of childs exeeded (3)
    >>> oc3.remove(fir2, oc3.root()[0])

Dynamic namespace expansion with multi occurence of objects
-----------------------------------------------------------

We will now extend the ObjectCollection ``oc3`` from the chapter above and add
for every object fir, sec, thi and fou another one:

    >>> oc3.index(fir)
    >>> oc3.add(sec, fir)
    >>> oc3.add(thi, sec)
    >>> oc3.add(fou, thi)

Now test if the extended compare works:

    >>> oc3._compare_namespace(oc3._namespace[thi][0],
    ...                        oc3._namespace[sec][0])
    True
    >>> oc3._compare_namespace(oc3._namespace[sec][0],
    ...                        oc3._namespace[thi][0])
    False
