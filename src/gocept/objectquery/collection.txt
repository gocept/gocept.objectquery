======================
Using ObjectCollection
======================

Imporing the ObjectCollection
=============================

You can import the QueryParser as follow:

    >>> from gocept.objectquery.collection import ObjectCollection

Get a ObjectCollection:

    >>> oc = ObjectCollection()

Using the ObjectCollection
==========================

How to add objects to the ObjectCollection
------------------------------------------

ObjectCollection is looking inside objects for other objects. You have the
following possibilities to add preceding objects.

    >>> class Child(object):
    ...     pass

Tupels:

    >>> class Parent(object):
    ...     def __init__(self):
    ...         self.ref_tupel = (Child(), Child())
    >>> obj = Parent()
    >>> oc.add(obj)
    >>> oc.root() == obj
    True
    >>> oc.remove(oc.root())

Lists:

    >>> class Parent(object):
    ...     def __init__(self):
    ...         self.ref_list = [Child(), Child()]
    >>> obj = Parent()
    >>> oc.add(obj)
    >>> oc.remove(oc.root())

Dictionaries:

    >>> class Parent(object):
    ...     def __init__(self):
    ...         self.ref_dict = {"elem1": Child(), "elem2": Child()}
    >>> obj = Parent()
    >>> oc.add(obj)
    >>> oc.remove(oc.root())

Variables:

    >>> class Parent(object):
    ...     def __init__(self):
    ...         self.ref_var = Child()
    >>> obj = Parent()
    >>> oc.add(obj)
    >>> oc.remove(oc.root())

Example usage of ObjectCollection
---------------------------------

First create some classes. All have the attribute ``ref`` which holds more
subclasses to add.

    >>> class Telephone(object):
    ...     def __init__(self, number="", ref=None):
    ...         if ref is None:
    ...           ref = []
    ...         self.ref = ref
    ...         self.number = number
    >>> class Person(object):
    ...     def __init__(self, name="", ref=None):
    ...         if ref is None:
    ...           ref = []
    ...         self.ref = ref
    ...         self.name = name
    >>> class Address(object):
    ...     def __init__(self, street="", city="", ref=None):
    ...         if ref is None:
    ...           ref = []
    ...         self.ref = ref
    ...         self.street = street
    ...         self.city = city

Add some objects to the collection:

    >>> t1 = Telephone(number="22988912")
    >>> t2 = Telephone(number="22988913")
    >>> p1 = Person(name="Sebastian")
    >>> p1.ref = [t1, t2]
    >>> a1 = Address(street="Meckelstrasse", city="Halle")
    >>> a1.ref = [p1]
    >>> oc.add(a1)
    >>> oc.all()
    [<Address object at 0x...>, <Person object at 0x...>, <Telephone object at 0x...>, <Telephone object at 0x...>]

Search by classname:

    >>> oc.by_class("Telephone")
    [<Telephone object at 0x...>, <Telephone object at 0x...>]
    >>> oc.by_class("Address")
    [<Address object at 0x...>]

Now search for some object attributes:

    >>> oc.by_attr("number", "22988912")
    [<Telephone object at 0x...>]
    >>> oc.by_attr("city", "Halle")
    [<Address object at 0x...>]
    >>> oc.by_attr("street", "")
    []

Adding and removing objects:
----------------------------

Adding some more objects to ``oc``:

    >>> p2 = Person(name="Christian")
    >>> a1.ref.append(p2)
    >>> oc.add(p2, a1)
    >>> oc.by_class("Person")
    [<Person object at 0x...>, <Person object at 0x...>]

    >>> t3 = Telephone(number="2298891")
    >>> p2.ref.append(t3)
    >>> oc.add(t3, p2)
    >>> oc.by_class("Telephone")
    [<Telephone object at 0x...>, <Telephone object at 0x...>, <Telephone object at 0x...>]

    >>> oc.add(t3, p1)
    >>> oc.by_class("Telephone")
    [<Telephone object at 0x...>, <Telephone object at 0x...>, <Telephone object at 0x...>, <Telephone object at 0x...>]

Successful removing:

    >>> p1.ref.remove(t1)
    >>> oc.remove(t1, p1)
    >>> oc.by_class("Telephone")
    [<Telephone object at 0x...>, <Telephone object at 0x...>]

Removing objects which do not exist under parent (but under anoÃ¾her parent), is well ignored:

    >>> oc.remove(t3, p1)
    >>> oc.by_class("Telephone")
    [<Telephone object at 0x...>, <Telephone object at 0x...>]

Removing objects from parents, which do not exist, raises an error:

    >>> oc.remove(t3, p3)
    Traceback (most recent call last):
    ...
    NameError: name 'p3' is not defined

Same with objects, which do not exist:

    >>> oc.remove(t4, p1)
    Traceback (most recent call last):
    ...
    NameError: name 't4' is not defined

Adding and removing equal objects multiple times
------------------------------------------------

First we need a new ObjectCollection and a RootObject:

    >>> oc2 = ObjectCollection()
    >>> class RootObject(object):
    ...     pass
    >>> root = RootObject()
    >>> oc2.add(root)

Then we generate a tree structure with one Address as root, followed by two
equal Persons. Person is followed by two equal Telephones:

    >>> tele = Telephone()
    >>> pers = Person(ref=[tele, tele])
    >>> addr = Address(ref=[pers, pers])
    >>> oc2.add(addr, root)

Now we have 4 Telephone objects as leaves:

    >>> len(oc2.by_class("Telephone"))
    4

Add another Telephone (the same as added above) to Person:

    >>> pers.ref.append(tele)
    >>> oc2.add(tele, pers)

Now we have 6 Telephone objects as leaves:

    >>> len(oc2.by_class("Person"))
    2
    >>> len(oc2.by_class("Telephone"))
    6

Now add Address for a second time to the Collection:

    >>> oc2.add(addr, root)

Now we have 2 Address, 4 Person and 12 Telephone objects as leaves:

    >>> len(oc2.by_class("Address"))
    2
    >>> len(oc2.by_class("Person"))
    4
    >>> len(oc2.by_class("Telephone"))
    12

Now add a third and fourth Person to Address:

    >>> addr.ref.append(pers)
    >>> oc2.add(pers, addr)
    >>> addr.ref.append(pers)
    >>> oc2.add(pers, addr)

There are now 8 Person (every 4 under Address) and 24 Telephone objects:

    >>> len(oc2.by_class("Person"))
    8
    >>> len(oc2.by_class("Telephone"))
    24

Last add a third Address into the Collection:

    >>> oc2.add(addr, root)

There are now 12 Person and 36 Telephone objects:

    >>> len(oc2.by_class("Person"))
    12
    >>> len(oc2.by_class("Telephone"))
    36

Add another Telephone (the same as added above) to Person:

    >>> pers.ref.append(tele)
    >>> oc2.add(tele, pers)

There are now 12 Person and 48 Telephone objects:

    >>> len(oc2.by_class("Person"))
    12
    >>> len(oc2.by_class("Telephone"))
    48

Remove the Person from Address object:

    >>> addr.ref.remove(pers)
    >>> oc2.remove(pers, addr)

As the Telephones are removed with the Persons, we now have no Telephone
leaves:

    >>> len(oc2.by_class("Telephone"))
    0

Adding circles to collection
----------------------------

First we need a new ObjectCollection:

    >>> oc3 = ObjectCollection()
    >>> oc3.add(root)

    >>> a = Address()
    >>> p = Person()
    >>> oc3.add(a, root)
    >>> oc3.add(p, a)

Now adding a under p should raise an exception:

    >>> oc3.add(a, p)
    Traceback (most recent call last):
    ...
    ValueError: Cannot add object <...>. Cycle detected.

But you can add a under root:

    >>> oc3.add(a, root)
    >>> oc3.is_direct_child(a, root)
    True

Testing Attribute Index
-----------------------

First we need a new ObjectCollection:

    >>> oc4 = ObjectCollection()

Define some objects with attributes:

    >>> class Root(object):
    ...     def __init__(self):
    ...         self.link_tuple = ()
    ...         self.link_list = []
    ...         self.link_dict = {}
    ...         self.direct_link = ""
    >>> class Child(Root):
    ...     pass
    >>> ch1 = Child()
    >>> ch2 = Child()
    >>> ch3 = Child()
    >>> root = Root()
    >>> root.direct_link = ch2
    >>> root.link_tuple = (ch1, ch3)
    >>> oc4.add(root)

Test some reachabilities:

    >>> oc4.by_attr_reach(ch1, root, "direct_link")
    False
    >>> oc4.by_attr_reach(ch1, root, "link_tuple")
    True
    >>> oc4.by_attr_reach(ch2, root, "link_tuple")
    False
