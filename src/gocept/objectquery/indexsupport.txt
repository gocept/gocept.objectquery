==================
Using IndexSupport
==================

Initialization
==============

Import and create a ZODB to store the indexes:

    >>> from ZODB import FileStorage, DB
    >>> from persistent import Persistent
    >>> import transaction
    >>> storage = FileStorage.FileStorage('/tmp/test-indexsupport.fs')
    >>> db = DB(storage)
    >>> conn = db.open()
    >>> dbroot = conn.root()
    >>> dbroot.clear()
    >>> transaction.commit()

ClassIndex
==========

Get a ClassIndex object:

    >>> from gocept.objectquery.indexsupport import ClassIndex
    >>> ci = ClassIndex(dbroot)

ClassIndex's index is a BTrees.OOBTree object:

    >>> ci.index
    <BTrees.OOBTree.OOBTree object at 0x...>

ClassIndex holds integer values (like Object Identifiers from ZODB):

    >>> ci.insert("Course", 1)
    >>> ci.insert("Student", 2)
    >>> ci.insert("Student", 3)

Validate the stored data:

    >>> ci.has_key('Student')
    True
    >>> ci.get('Student')
    [2, 3]
    >>> ci.has_key('Foo')
    False
    >>> ci.get('Course')
    [1]
    >>> ci.all()
    [1, 2, 3]

Delete some items from the index:

    >>> ci.delete("Student", 2)
    >>> ci.get('Student')
    [3]
    >>> ci.delete("Student", 2)
    Traceback (most recent call last):
    ...
    KeyError: 2
    >>> ci.delete("Course", 1)
    >>> ci.get("Course")
    Traceback (most recent call last):
    ...
    KeyError: 'Course'

AttributeIndex
==============

AttributeIndex works the same as the ClassIndex, so it is ok to only test if
we can get it:

    >>> from gocept.objectquery.indexsupport import AttributeIndex
    >>> ai = AttributeIndex(dbroot)

Lets have a look on our dbroot object:

    >>> dbroot.has_key('_is_AttributeIndex')
    True
    >>> dbroot.has_key('_is_ClassIndex')
    True

StructureIndex
==============

First, get a StructureIndex:

    >>> from gocept.objectquery.indexsupport import StructureIndex
    >>> si = StructureIndex(dbroot)

Insert some values:

    >>> si.insert(1)
    >>> si.insert(2, 1)
    >>> si.insert(3, 1)
    >>> si.insert(2, 3)
    >>> si.insert(4, 2)
    >>> si.insert(5, 1)
    >>> si.insert(4, 5)

StructureIndex stores the childs of a key for internal tasks:

    >>> si.index['childs'][1]
    [2, 3, 5]
    >>> si.index['childs'][4]
    []

The private method get lists all paths to the given element:

    >>> si.get(2)
    [(1, 2), (1, 3, 2)]
    >>> si.get(3)
    [(1, 3)]
    >>> si.get(4)
    [(1, 2, 4), (1, 3, 2, 4), (1, 5, 4)]

Check the parent-child-relationship:

    >>> si.is_parent(1, 2)     # is 1 the parent of 2
    True
    >>> si.is_parent(2, 3)
    False
    >>> si.is_child(1, 2)      # is 1 the child of 2
    False
    >>> si.is_parent(2, 3)
    False
    >>> si.is_child(1, 2) is not si.is_parent(1,2)
    True

    >>> si.is_predecessor(1, 4) # is 1 the predecessor of 4
    True
    >>> si.is_predecessor(4, 2)
    False
    >>> si.is_successor(4, 1)   # is 4 a successor of 1
    True
    >>> si.is_successor(1, 4)
    False
    >>> si.is_predecessor(1, 4) is not si.is_successor(1, 4)
    True

You may also validate an element against a list of (sub-)indexes:

    >>> si.validate(3, [(1, )])
    True
    >>> si.validate(2, [(1, 5)])
    False
    >>> si.validate(2, [(1, 5), (1, 2)])
    True
    >>> si.validate(4, [(1, 3)])
    True

You delete keys as follows:

    >>> si.delete(2, 3)
    >>> si.get(2)
    [(1, 2)]
    >>> si.get(4)
    [(1, 2, 4), (1, 5, 4)]
    >>> si.delete(2)
    >>> si.get(4)
    [(1, 5, 4)]
    >>> si.delete(5)
    >>> si.get(4)
    Traceback (most recent call last):
    ...
    KeyError: 4
    >>> si.get(3)
    [(1, 3)]

Lets look at the childs index:

    >>> list(si.index['childs'])
    [0, 1, 3]
    >>> si.index['childs'][1]
    [3]
    >>> si.index['childs'][2]
    Traceback (most recent call last):
    ...
    KeyError: 2
    >>> si.index['childs'][3]
    []

Special cases
=============

Delete the first node:

    >>> si.delete(1, 0)
    >>> si.get(1)
    Traceback (most recent call last):
    ...
    KeyError: 1
    >>> list(si.index['childs'])
    [0]

Cycles are supported as well:

    >>> si.insert(1)
    >>> si.insert(2, 1)
    >>> si.insert(3, 2)
    >>> si.insert(1, 3)

    >>> si.get(3)
    [(1, 2, 3), (1, 2, 3, 1, 2, 3)]
    >>> si.get(1)
    [(1,), (1, 2, 3, 1)]

    >>> si.is_predecessor(3, 1)
    True
    >>> si.is_successor(3, 1)
    True

Delete the cycle:

    >>> si.delete(1, 3)
    >>> si.get(3)
    [(1, 2, 3)]
    >>> si.get(1)
    [(1,)]

Adding a ``second way'' (2, 4)  within an existing tree must replicate to all
childs (node 3):

    >>> si.insert(4, 1)
    >>> si.get(3)
    [(1, 2, 3)]

    >>> si.insert(2, 4)
    >>> si.get(2)
    [(1, 2), (1, 4, 2)]
    >>> si.get(3)
    [(1, 2, 3), (1, 4, 2, 3)]

    >>> dbroot.clear()
    >>> transaction.commit()
