================================
Parsing regular path expressions
================================

Imporing the QueryParser
========================

You can import the QueryParser as follow:

    >>> from gocept.objectquery.pathexpressions import RPEQueryParser

Get a QueryParer:

    >>> p = RPEQueryParser()

Some examples how to use the QueryPaser
=======================================

The Parser returns a data structure, which allows to recursively call the
Join-Functions with two parameters. Here a simple example, where we join the
element *foo* with the element *bar*:

    >>> p.parse('foo/bar')
    ['EEJOIN', ('ELEM', 'foo'), ('ELEM', 'bar')]

It is also possible, to find only root elements:

    >>> p.parse('/foo')
    ['EEJOIN', None, ('ELEM', 'foo')]

But trailing path separators are **not** allowed:

    >>> p.parse('foo/')
    Traceback (most recent call last):
    ...
    SyntaxError: ...

Occurrence works the same way: it's an KCJOIN with the occurrence parameter
(+,?,*) and an element:

    >>> p.parse('/foo?')
    ['EEJOIN', None, ['KCJOIN', '?', ('ELEM', 'foo')]]
    >>> p.parse('foo*/bar')
    ['EEJOIN', ['KCJOIN', '*', ('ELEM', 'foo')], ('ELEM', 'bar')]

More Pathjoins work like a tree, where the leaves are the elements:

    >>> p.parse('foo/bar/bou')
    ['EEJOIN', ['EEJOIN', ('ELEM', 'foo'), ('ELEM', 'bar')], ('ELEM', 'bou')]

Attributes are parsed the same way: an ATTR-Function with ID and VALUE as
parameters:

    >>> p.parse('foo/bar*[@a="b"]')
    ['EEJOIN', ('ELEM', 'foo'), ['EAJOIN', ['ATTR', ('a', 'b', '=')], ['KCJOIN', '*', ('ELEM', 'bar')]]]

Attribute values may contain quoted strings:

    >>> p.parse('foo/bar[@a=="b\"c d\"e"]')
    ['EEJOIN', ('ELEM', 'foo'), ['EAJOIN', ['ATTR', ('a', 'b"c d"e', '==')], ('ELEM', 'bar')]]

    >>> p.parse('foo/bar[@a<"b"c d"e"]')
    ['EEJOIN', ('ELEM', 'foo'), ['EAJOIN', ['ATTR', ('a', 'b"c d"e', '<')], ('ELEM', 'bar')]]

Attribute vales may also be empty:

    >>> p.parse('/foo[@A>=""]')
    ['EEJOIN', None, ['EAJOIN', ['ATTR', ('A', '', '>=')], ('ELEM', 'foo')]]

Element can also be a wildcard:

    >>> p.parse('/_*/bar')
    ['EEJOIN', None, '/_*/', ('ELEM', 'bar')]

To show the mightiness of the parser, here a more complex example:

    >>> p.parse('/foo[@a!="b"]/_*/bar+[@a2="b2 b3"]/fou')
    ['EEJOIN', ['EEJOIN', ['EEJOIN', None, ['EAJOIN', ['ATTR', ('a', 'b', '!=')], ('ELEM', 'foo')]], '/_*/', ['EAJOIN', ['ATTR', ('a2', 'b2 b3', '=')], ['KCJOIN', '+', ('ELEM', 'bar')]]], ('ELEM', 'fou')]

You may also provide precedence by using round brackets and UNIONs. Here a
simple example:

    >>> p.parse('(foo/bar)|boo')
    ['UNION', ['PREC', ['EEJOIN', ('ELEM', 'foo'), ('ELEM', 'bar')]], ('ELEM', 'boo')]

And here the same example with changed precedence:

    >>> p.parse('foo|(bar/boo)')
    ['UNION', ('ELEM', 'foo'), ['PREC', ['EEJOIN', ('ELEM', 'bar'), ('ELEM', 'boo')]]]

A Union of two EEJOINS

    >>> p.parse('(foo/bar)|(boo/far)')
    ['UNION', ['PREC', ['EEJOIN', ('ELEM', 'foo'), ('ELEM', 'bar')]], ['PREC', ['EEJOIN', ('ELEM', 'boo'), ('ELEM', 'far')]]]

A really big example with everything possible included:

    >>> p.parse('(E1/E2)*/E3/((E4[@A="v"])|(E5/_*/E6))')
    ['EEJOIN', ['EEJOIN', ['KCJOIN', '*', ['PREC', ['EEJOIN', ('ELEM', 'E1'), ('ELEM', 'E2')]]], ('ELEM', 'E3')], ['PREC', ['UNION', ['PREC', ['EAJOIN', ['ATTR', ('A', 'v', '=')], ('ELEM', 'E4')]], ['PREC', ['EEJOIN', ('ELEM', 'E5'), '/_*/', ('ELEM', 'E6')]]]]]

Specify a ``way'' through the graph with .way:

    >>> p.parse('/foo.next_elem')
    ['EEJOIN', None, ['PWJOIN', ('ELEM', 'foo'), ('WAY', 'next_elem')]]
    >>> p.parse('(foo/bar.next)|(boo.next/far)')
    ['UNION', ['PREC', ['EEJOIN', ('ELEM', 'foo'), ['PWJOIN', ('ELEM', 'bar'), ('WAY', 'next')]]], ['PREC', ['EEJOIN', ['PWJOIN', ('ELEM', 'boo'), ('WAY', 'next')], ('ELEM', 'far')]]]

Here some negative RPE-Tests
============================

Empty querys are not allowed:

    >>> p.parse('')
    Traceback (most recent call last):
    ...
    SyntaxError: ...

Do not use only a path separator:

    >>> p.parse('/')
    Traceback (most recent call last):
    ...
    SyntaxError: ...

Double path separators are also not allowed:

    >>> p.parse('//foo')
    Traceback (most recent call last):
    ...
    SyntaxError: ...

Another example of a non-complete query:

    >>> p.parse('foo[a="v"]')
    Traceback (most recent call last):
    ...
    SyntaxError: ...

Opening brackets must be closed:

    >>> p.parse('((abc/def)|(ghi/jkl)')
    Traceback (most recent call last):
    ...
    SyntaxError: ...

Union needs two parameters at all:

    >>> p.parse('(foo)|')
    Traceback (most recent call last):
    ...
    SyntaxError: ...

Empty brackets are not allowed:

    >>> p.parse('()')
    Traceback (most recent call last):
    ...
    SyntaxError: ...

Quotet strings in attribute values must be quoted correctly:

    >>> p.parse('foo/bar[@a="b\"c de"]')
    Traceback (most recent call last):
    ...
    SyntaxError: ...

    >>> p.parse('foo/bar[@a="b"c de"]')
    Traceback (most recent call last):
    ...
    SyntaxError: ...
