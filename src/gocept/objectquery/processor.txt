==============================================
Querying objects with regular path expressions
==============================================

Create QueryProcessor and initialize the ObjectCollection
---------------------------------------------------------

You create a QueryProcessor like this:

    >>> from gocept.objectquery.pathexpressions import RPEQueryParser
    >>> from gocept.objectquery.collection import ObjectCollection
    >>> from gocept.objectquery.processor import QueryProcessor
    >>> parser = RPEQueryParser()
    >>> objects = ObjectCollection()
    >>> query = QueryProcessor(parser, objects)
    >>> query
    <gocept.objectquery.processor.QueryProcessor object at 0x...>

Fill the collection with some examples:

    >>> class Telephone(object):
    ...     def __init__(self, ref=None, number=""):
    ...         if ref is None: ref = []
    ...         self.ref = ref
    ...         self.number = number
    >>> class Person(object):
    ...     def __init__(self, ref=None, name=""):
    ...         if ref is None: ref = []
    ...         self.ref = ref
    ...         self.name = name
    >>> class Address(object):
    ...     def __init__(self, ref=None, street="", etage=""):
    ...         if ref is None: ref = []
    ...         self.ref = ref
    ...         self.street = street
    ...         self.etage = etage
    >>> class AddressBook(object):
    ...     pass

Now fill the classes with some data:

    >>> t1 = Telephone(number="22988912")
    >>> t2 = Telephone(number="2298890")
    >>> t3 = Telephone(number="2298891")
    >>> p1 = Person(name="Theuni")
    >>> p2 = Person(name="Basti", ref=[t1])
    >>> p3 = Person(name="coco", ref=[t2, t3])
    >>> a1 = Address(street="Meckelstrasse", etage="2")
    >>> a2 = Address(street="Forsterstrasse", etage="2", ref=[p1, p2])
    >>> a3 = Address(street="Forsterstrasse", etage="1", ref=[p3])
    >>> ab = AddressBook()
    >>> objects.add(ab)
    >>> objects.add(a1, ab)
    >>> objects.add(a2, ab)
    >>> objects.add(a3, ab)

Some example usecases
---------------------

Root joins:

    >>> r = query('/Address')
    >>> len(r)
    3
    >>> r = query('/Telephone')
    >>> len(r)
    0

Give all Telephones that are direct childs of Adresses:

    >>> r = query('Address/Telephone')
    >>> len(r)
    0

Give the Telephone of all Persons named "coco":

    >>> r = query('Address/Person[@name="coco"]/Telephone')
    >>> len(r)
    2
    >>> r[0].number
    '2298891'

Give all Persons, that live in "Forsterstrasse":

    >>> r = query('Address[@street="Forsterstrasse"]/Person*')
    >>> len(r)
    3

Give the Telephones of Persons who live *alone* at Forsterstrasse:

    >>> r = query('Address[@street="Forsterstrasse"]/Person?/Telephone')
    >>> len(r)
    2
    >>> r[0].number
    '2298891'

Handle Wildcards correctly:

    >>> r = query('/Address/_+/Telephone')
    >>> len(r)
    3

What about precedence:

    >>> r = query('/Address[@street="Forsterstrasse"]/Person/Telephone')
    >>> len(r)
    3
    >>> r = query('(/Address[@street="Forsterstrasse"]/Person)/Telephone')
    >>> len(r)
    3
    >>> r = query('/Address[@street="Forsterstrasse"]/(Person/Telephone)')
    >>> len(r)
    0
    >>> r = query('(/Address/Person[@name="Basti"])/(Person/Telephone)')
    >>> len(r)
    1


But pay attention. If you change the query from .."]/(Pers.. to .."](/Pers..
you get an Address-Result with street name "Forsterstrasse":

    >>> r = query('/Address[@street="Forsterstrasse"](/Person/Telephone)')
    >>> len(r)
    2
    >>> r[0].street
    'Forsterstrasse'

Unions:

    >>> r = query('(/Address[@street="Forsterstrasse"])|(Person/Telephone)')
    >>> len(r)
    5
    >>> r = query('(/Address)|(Person[@name="Basti"])')
    >>> len(r)
    4

Advanced usecases
-----------------

Move ``t2`` from ``p3`` to ``p1``:

    >>> r = query('Person[@name="coco"]/Telephone')
    >>> len(r)
    2
    >>> r = query('Person[@name="Theuni"]/Telephone')
    >>> len(r)
    0

    >>> p3.ref.remove(t2)
    >>> p1.ref.append(t2)
    >>> objects.move(t2, p3, p1)

    >>> r = query('Person[@name="coco"]/Telephone')
    >>> len(r)
    1
    >>> r = query('Person[@name="Theuni"]/Telephone')
    >>> len(r)
    1

Remove ``a1``:

    >>> objects.remove(a1, ab)
    >>> r = query('Person[@name="coco"]/Telephone')
    >>> len(r)
    1
    >>> r = query('Person/Telephone')
    >>> len(r)
    3

Add same object more than once:

    >>> p3.ref.append(t2)
    >>> objects.add(t2, p3)
    >>> r = query('Person[@name="coco"]/Telephone')
    >>> len(r)
    2
    >>> r = query('Person/Telephone')
    >>> len(r)
    4

``r[0]`` and ``r[3]`` are now both t2 one and the same object:

    >>> id(r[0]) == id(r[3])
    True
    >>> id(r[1]) == id(r[3])
    False

Add and remove ``t1`` under ``p3``:

    >>> p3.ref.append(t1)
    >>> objects.add(t1, p3)
    >>> r = query('Person/Telephone')
    >>> len(r)
    5
    >>> p3.ref.remove(t1)
    >>> objects.remove(t1, p3)
    >>> r = query('Person/Telephone')
    >>> len(r)
    4

Now add ``p3`` under ``a2``:

    >>> a2.ref.append(p3)
    >>> objects.add(p3, a2)
    >>> r = query('Person/Telephone')
    >>> len(r)
    6

Testcase to verify a correct removing with duplicated entrieÑ•
-------------------------------------------------------------

Make a new ObjectCollection with Parser:

    >>> oc = ObjectCollection()
    >>> q = QueryProcessor(parser, oc)

Get new classes:

    >>> class Root(object):
    ...     pass
    >>> class X(object):
    ...     pass
    >>> class Y(object):
    ...     pass
    >>> class Z(object):
    ...     pass

    >>> root = Root()
    >>> x = X()
    >>> y = Y()
    >>> z = Z()

Add them to ObjectCollection:

    >>> oc.add(root)
    >>> oc.add(x, root)
    >>> oc.add(x, root)
    >>> oc.add(z, root)
    >>> oc.add(y, x)
    >>> oc.add(y, z)
    >>> oc.all()
    [<Root...>, <X...>, <Y...>, <X...>, <Y...>, <Z...>, <Y...>]

Now remove ``Y`` from ``X``:

    >>> oc.remove(y, x)
    >>> oc.all()
    [<Root...>, <X...>, <X...>, <Z...>, <Y...>]
    >>> r = q("_/Y")
    >>> len(r)
    1

Add ``Z`` under ``X``:

    >>> oc.add(z, x)
    >>> oc.all()
    [<Root...>, <X...>, <Z...>, <Y...>, <X...>, <Z...>, <Y...>, <Z...>, <Y...>]
    >>> len(oc.all())
    9
    >>> r = q("_/Y")
    >>> len(r)
    3

Create a fourth class ``A`` and move ``Y`` from ``Z`` under it:

    >>> class A(object):
    ...     pass
    >>> a = A()
    >>> oc.add(a, root)
    >>> oc.move(y, z, a)
    >>> oc.all()
    [<Root...>, <X...>, <Z...>, <X...>, <Z...>, <Z...>, <A...>, <Y...>]
    >>> len(oc.all())
    8
    >>> r = q("X/Z")
    >>> len(r)
    2

Verify that querying multiple equal objects results in a correct count
----------------------------------------------------------------------

First set up the test environment:

    >>> oc = ObjectCollection()
    >>> q = QueryProcessor(parser, oc)
    >>> oc.all()
    []

    >>> class Root(object):
    ...     pass
    >>> class X(object):
    ...     pass
    >>> class Y(object):
    ...     id = ""
    >>> class Z(object):
    ...     id = ""

    >>> root = Root()
    >>> x1 = X()
    >>> x2 = X()
    >>> y1 = Y()
    >>> y1.id = "1"
    >>> y2 = Y()
    >>> y2.id = "2"
    >>> y3 = Y()
    >>> y3.id = "3"
    >>> z1 = Z()
    >>> z1.id = "1"
    >>> z2 = Z()
    >>> z2.id = "2"
    >>> z3 = Z()
    >>> z3.id = "3"

    >>> oc.add(root)
    >>> oc.add(x1, root)
    >>> oc.add(x2, root)
    >>> oc.add(y1, x1)
    >>> oc.add(y2, x1)
    >>> oc.add(y3, x2)
    >>> oc.add(z1, y1)
    >>> oc.add(z2, y2)
    >>> oc.add(z3, y3)
    >>> oc.all()
    [<Root...>, <X...>, <Y...>, <Z...>, <Y...>, <Z...>, <X...>, <Y...>, <Z...>]
    >>> len(oc.all())
    9

Nothing really new until here, but now we link ``Z2`` under ``Y3``, so that it
can be reached over ``Y2`` and ``Y3``:

    >>> oc.add(z2, y3)
    >>> oc.all()
    [<Root...>, <X...>, <Y...>, <Z...>, <Y...>, <Z...>, <X...>, <Y...>, <Z...>, <Z...>]
    >>> len(oc.all())
    10

If we now query for all ``Z``, we should receive 4 items:

    >>> r = q("_/Z")
    >>> len(r)
    4

If we query for all ``Z`` under ``Y3`` we should return 2 results (``Z2`` and
``Z3``):

    >>> r = q('Y[@id="3"]/Z')
    >>> len(r)
    2

``Z`` under ``Y2`` and ``Y1`` should each return one result:

    >>> r = q('Y[@id="2"]/Z')
    >>> len(r)
    1
    >>> r = q('Y[@id="1"]/Z')
    >>> len(r)
    1
