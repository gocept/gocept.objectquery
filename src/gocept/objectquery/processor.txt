==============================================
Querying objects with regular path expressions
==============================================

Initialization
==============

First we need a ZODB for the IndexSupport used by ObjectCollection:

    >>> from ZODB import FileStorage, DB
    >>> from persistent import Persistent
    >>> import transaction
    >>> storage = FileStorage.FileStorage('/tmp/test-processor.fs')
    >>> db = DB(storage)
    >>> conn = db.open()
    >>> dbroot = conn.root()

Purge old data:

    >>> dbroot.clear()
    >>> transaction.commit()

Then we need some testobjects, which we will store into the ObjectCollection:

    >>> import gocept.objectquery.testobjects as testobject

Create QueryProcessor and initialize the ObjectCollection
=========================================================

You create a QueryProcessor like this:

    >>> from gocept.objectquery.pathexpressions import RPEQueryParser
    >>> from gocept.objectquery.collection import ObjectCollection
    >>> from gocept.objectquery.processor import QueryProcessor
    >>> parser = RPEQueryParser()
    >>> objects = ObjectCollection(conn)
    >>> query = QueryProcessor(parser, objects)
    >>> query
    <gocept.objectquery.processor.QueryProcessor object at 0x...>

Now fill the database with some data:

    >>> t1 = testobject.Telephone(number="22988912")
    >>> t2 = testobject.Telephone(number="2298890")
    >>> t3 = testobject.Telephone(number="2298891")
    >>> p1 = testobject.Person(name="Theuni")
    >>> p2 = testobject.Person(name="Basti", private=[t1])
    >>> p3 = testobject.Person(name="coco", work=[t2, t3])
    >>> a1 = testobject.Address(street="Meckelstrasse", floor="2")
    >>> a2 = testobject.Address(street="Forsterstrasse", floor="2", ref=[p1, p2])
    >>> a3 = testobject.Address(street="Forsterstrasse", floor="1", ref=[p3])
    >>> ab = testobject.AddressBook(ref=[a1, a2, a3])

    >>> dbroot['test'] = ab
    >>> transaction.commit()
    >>> objects.add(ab._p_oid)

Some example usecases
---------------------

Root joins:

    >>> r = query('/Address')
    >>> len(r)
    3
    >>> r = query('/Telephone')
    >>> len(r)
    0

Give all Telephones that are direct childs of Adresses:

    >>> r = query('Address/Telephone')
    >>> len(r)
    0

Give the Telephone of all Persons named "coco":

    >>> r = query('Address/Person[@name="coco"]/Telephone')
    >>> len(r)
    2
    >>> sorted(elem.number for elem in r)
    ['2298890', '2298891']

Give all Persons that do not live in the first floor:

    >>> r = query('Address[@floor!="1"]/Person')
    >>> len(r)
    2
    >>> r[0].name != 'coco' and r[1].name != 'coco'
    True

Give all Persons that live on a floor smaller than 2:

    >>> r = query('Address[@floor<"2"]/Person')
    >>> len(r)
    1
    >>> r[0].name == 'coco'
    True

Handle Wildcards correctly:

    >>> r = query('/Address/_/Telephone')
    >>> len(r)
    3

What about precedence:

    >>> r = query('/Address[@street="Forsterstrasse"]/Person/Telephone')
    >>> len(r)
    3
    >>> r = query('(/Address[@street="Forsterstrasse"]/Person)/Telephone')
    >>> len(r)
    3
    >>> r = query('/Address[@street="Forsterstrasse"]/(Person/Telephone)')
    >>> len(r)
    0
    >>> r = query('(/Address/Person[@name="Basti"])/(Person/Telephone)')
    >>> len(r)
    1

But pay attention. If you change the query from .."]/(Pers.. to .."](/Pers..
you get an Address-Result with street name "Forsterstrasse":

    >>> r = query('/Address[@street="Forsterstrasse"](/Person/Telephone)')
    >>> len(r)
    2
    >>> r[0].street
    'Forsterstrasse'

Unions:

    >>> r = query('(/Address[@street="Forsterstrasse"])|(Person/Telephone)')
    >>> len(r)
    5
    >>> r = query('(/Address)|(Person[@name="Basti"])')
    >>> len(r)
    4

Pathways:

    >>> r = query('Person.work/Telephone')
    >>> len(r)
    2
    >>> r = query('Person.work/Telephone[@number="2298890"]')
    >>> len(r)
    1
